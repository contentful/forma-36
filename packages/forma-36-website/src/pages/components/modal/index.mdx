---
title: 'Modal'
type: 'component'
status: 'stable'
github: 'https://github.com/contentful/forma-36/tree/master/packages/forma-36-react-components/src/components/Modal'
storybook: 'https://f36-storybook.contentful.com/?path=/story/components-modal--default'
---

Modal dialogs interrupt a user by isolating information that needs to be acted upon. They are often triggered by an action a user took, and should be used to inform, confirm or complete a task.

```jsx
function ModalExample() {
  const [isShown, setShown] = React.useState(false);
  return (
    <React.Fragment>
      <Button onClick={() => setShown(true)}>Show centered modal</Button>
      <Modal title="Centered modal" isShown={isShown}>
        {() => (
          <React.Fragment>
            <Modal.Header title="Title" />
            <Modal.Content>Hello from controlled modal window</Modal.Content>
            <Modal.Controls>
              <Button buttonType="positive" onClick={() => setShown(false)}>
                Confirm
              </Button>
              <Button buttonType="muted" onClick={() => setShown(false)}>
                Close
              </Button>
            </Modal.Controls>
          </React.Fragment>
        )}
      </Modal>
    </React.Fragment>
  );
}
```

## Table of contents

1. [Best practices](#best-practices)
2. [Variations](#variations)
   1. [Modal position](#modal-position)
   2. [Modal sizes](#modal-sizes)
3. [Writing guidelines](#writing-guidelines)
4. [Using the modal launcher](#using-the-modal-launcher)

## Best practices <a name="best-practices" />

- Use modal dialogs to request information critical for a user to continue their current process
- Use modal dialogs to warn users about a potentially destructive action they are taking
- Use modal dialogs consistently across use cases
- Do not use modal dialogs for nonessential information that is not related to the current user flow
- Avoid modal dialogs that interrupt high-stake processes such as checkout flows

## Modal variations <a name="variations" />

The Modal component can be configured in a number of different ways. Use this guidance to determine when to use certain variations:

### Modal position (`position`) <a name="modal-position" />

```jsx
function ModalExample() {
  const [isShown, setShown] = React.useState(false);
  const [position, setPosition] = React.useState('top');
  return (
    <React.Fragment>
      <Form>
        <FieldGroup row>
          <Button
            buttonType="positive"
            onClick={() => {
              setPosition('top');
              setShown(true);
            }}
          >
            Show top modal
          </Button>
          <Button
            onClick={() => {
              setPosition('center');
              setShown(true);
            }}
          >
            Show center modal
          </Button>
        </FieldGroup>
      </Form>
      <Modal title="Centered modal" isShown={isShown} position={position}>
        {() => (
          <React.Fragment>
            <Modal.Header title="Title" />
            <Modal.Content>Hello from controlled modal window</Modal.Content>
            <Modal.Controls>
              <Button buttonType="positive" onClick={() => setShown(false)}>
                Confirm
              </Button>
              <Button buttonType="muted" onClick={() => setShown(false)}>
                Close
              </Button>
            </Modal.Controls>
          </React.Fragment>
        )}
      </Modal>
    </React.Fragment>
  );
}
```

### Modal sizes (`size`) <a name="modal-sizes" />

```jsx
function ModalExample() {
  const [isShown, setShown] = React.useState(false);
  const [size, setSize] = React.useState('medium');
  return (
    <React.Fragment>
      <Form>
        <SelectField
          onChange={e => {
            setSize(e.target.value);
          }}
          labelText="Select a width"
        >
          <Option value="small">small</Option>
          <Option value="medium">medium</Option>
          <Option value="large">large</Option>
          <Option value="fullWidth">full width</Option>
          <Option value="200px">200px (specific width value)</Option>
        </SelectField>
        <Button
          onClick={() => {
            setShown(true);
          }}
        >
          Show modal
        </Button>
      </Form>
      <Modal title="Centered modal" isShown={isShown} size={size}>
        {() => (
          <React.Fragment>
            <Modal.Header title="Title" />
            <Modal.Content>Hello from controlled modal window</Modal.Content>
            <Modal.Controls>
              <Button buttonType="positive" onClick={() => setShown(false)}>
                Confirm
              </Button>
              <Button buttonType="muted" onClick={() => setShown(false)}>
                Close
              </Button>
            </Modal.Controls>
          </React.Fragment>
        )}
      </Modal>
    </React.Fragment>
  );
}
```

## Writing guidelines <a name="writing-guidelines" />

- Practice progressive disclosure. Eliminate extra details to keep copy concise and actionable
- Focus on the objective of the modal dialog. Start each sentence with the objective when possible
- To enable users to navigate quickly, write concise sentences that are easy to understand at a glance
- Limit the number of concepts in each sentence. Write simple sentences for all audiences
- To keep UX copy actionable use present tense for user interactions
- Avoid “never,” “always” and other absolutes
- Use contractions when possible
- Avoid exclamation marks

## Using the modal launcher <a name="using-the-modal-launcher" />

The `ModalLauncher.open` utility can be used to wrap any custom result, based on a user's interaction with a Modal component, in a promise and await it.

```jsx
function() {
  const [hiddenText, setHiddenText] = React.useState('');

  return (
    <React.Fragment>
      <Button onClick={() => {
        ModalLauncher.open(({ isShown, onClose }) => (
          <Modal
            title="Reveal hidden text"
            isShown={isShown}
            onClose={() => onClose(hiddenText)}>
            {() => (
              <React.Fragment>
                <Modal.Header title="Reveal hidden text" />
                <Modal.Content>
                  Are you want to reveal the hidden text?
                </Modal.Content>
                <Modal.Controls>
                  <Button buttonType="positive" onClick={() => {
                    onClose('The text is revealed!');
                  }}>
                    Show text
                  </Button>
                  <Button buttonType="muted" onClick={() => onClose('')}>
                    Hide text
                  </Button>
                </Modal.Controls>
              </React.Fragment>
            )}
          </Modal>
        )).then((text) => {
          setHiddenText(text);
        })
      }}>
        Show Modal with ModalLauncher
      </Button>
      {hiddenText.length > 0 && (<Paragraph>{hiddenText}</Paragraph>)}
    </React.Fragment>
  )
}
```
