---
title: 'Autocomplete'
type: 'component'
status: 'stable'
slug: /components/autocomplete/
github: 'https://github.com/contentful/forma-36/tree/master/packages/components/autocomplete'
storybook: 'https://f36-storybook.contentful.com/?path=/story/components-autocomplete--basic'
typescript: ./src/Autocomplete.tsx
---

import { Props } from '@contentful/f36-docs-utils';

The autocomplete component is an input field that provides selectable options as a user types into it.
It allows users to quickly search through and select from large collections of options.

## Table of contents

- [How to use Autocomplete](#how-to-use-autocomplete)
- [Best practices](#best-practices)
- [Code examples](#code-examples)
  - [Highlighting an item](#highlighting-an-item)
  - [Using objects as items](#using-objects-as-items)
  - [Filling in a list of items](#filling-in-a-list-of-items)
  - [Error validation with FormControl](#error-validation-with-formcontrol)
  - [Fetching async data](#fetching-async-data)
- [Content recommendations](#content-recommendations)
- [Accessibility](#accessibility)
- [Props](#props)

## How to use Autocomplete

The Autocomplete requires 3 props to work:

- `items`: Itâ€™s an array containing the items that will be shown as selectable options when the user types something in the `TextInput`.
- `onInputValueChange`: This function will be called every time the user types something in the input.
  The component will pass the `item` which the filter method is currently interating and `inputValue` of the `Textinput`.
- `onSelectItem`: This function is called when the user selects one of the options of the list. The component will pass the selected item as an argument to the function.

An `Autocomplete` with a list of fruits will look like this:

```jsx
function AutocompleteExample() {
  const fruits = [
    'Apple ðŸŽ',
    'Ananas ðŸ',
    'Avocado ðŸ¥‘',
    'Banana ðŸŒ',
    'Coconut ðŸ¥¥',
  ];

  // This `useState` is going to store the selected fruit so we can show it in the UI
  const [selectedFruit, setSelectedFruit] = React.useState();

  const [filteredItems, setFilteredItems] = React.useState(fruits);

  // We filter the "fruits" array by the inputValue
  // we use 'toLowerCase()' to make the search case insensitive
  const handleInputValueChange = (value) => {
    const newFilteredItems = fruits.filter((item) =>
      item.toLowerCase().includes(value.toLowerCase()),
    );
    setFilteredItems(newFilteredItems);
  };

  // This function will be called once the user selects an item in the list of options
  const handleSelectItem = (item) => {
    setSelectedFruit(item);
  };

  return (
    <Stack flexDirection="column" alignItems="start">
      <Autocomplete
        items={filteredItems}
        onInputValueChange={handleInputValueChange}
        onSelectItem={handleSelectItem}
      />

      <Paragraph>Selected fruit: {selectedFruit}</Paragraph>
    </Stack>
  );
}
```

## Best practices

- Autocomplete should have a clear label so user understands what type of action is possible
- Consider using autocomplete over selects if a user will be choosing from a very long list, for example a country list.

## Code examples

## Highlighting an item

A common use case for Autocomplete components is to highlight the term that is being typed in the suggestions.
Using the previous example, if a user types "ana" we want to show a list of suggestions where "ana" is _bold_.
This is possible by using the `renderItem` prop and some regex:

```jsx static=true
<Autocomplete
  items={filteredItems}
  onInputValueChange={handleInputValueChange}
  onSelectItem={handleSelectItem}
  renderItem={(item, inputValue) => {
    // First, we create a regex that groups:
    // what comes before the match, the match, and what comes after the match
    const regex = new RegExp(
      `(?<before>.*?)(?<match>${inputValue})(?<after>.*)`,
      'i',
    );

    // if there are no matches, we return the item
    const matches = item.match(regex);
    if (!matches) return item;

    const {
      groups: { before, match, after },
    } = matches;

    // if there are matches, we wrap "match" with a <b> tag to make it bold
    return (
      <>
        {before}
        <b>{match}</b>
        {after}
      </>
    );
  }}
/>
```

#### highlightStringItem

The logic of the `renderItem` above will work when `items` is an array of strings. Since that's a very common case,
the autocomple package also provides a util function to highlight items that are strings. This is how to use it:

```jsx static=true
// We need to import the function from the `f36-autocomplete` package
import {
  Autocomplete,
  highlightStringItem,
} from '@contentful/f36-autocomplete';

<Autocomplete
  items={filteredItems}
  onInputValueChange={handleInputValueChange}
  onSelectItem={handleSelectItem}
  // Use the `renderItem` prop with the `highlightStringItem` util
  // to render the matched term wrapped in <b> tag
  renderItem={(item, inputValue) => highlightStringItem(item, inputValue)}
/>;
```

### Using objects as `items`

On the example in the ["How to use Autocomplete" section](#how-to-use-autocomplete), we showed how to create an Autocomplete with an array of string
but itâ€™s also possible to use other types of data as `items`. A very common way of using the Autocomplete is with objects and for that, with a few changes
to the Fruitâ€™s example this can be done:

```jsx
function AutocompleteExample() {
  // This is our new array of fruits, each one is an object with an id and a name
  const fruits = [
    { id: 1, name: 'Apple', emoji: 'ðŸŽ' },
    { id: 2, name: 'Ananas', emoji: 'ðŸ' },
    { id: 3, name: 'Avocado', emoji: 'ðŸ¥‘' },
    { id: 4, name: 'Banana', emoji: 'ðŸŒ' },
    { id: 5, name: 'Coconut', emoji: 'ðŸ¥¥' },
  ];

  const [selectedFruit, setSelectedFruit] = React.useState();
  const [filteredItems, setFilteredItems] = React.useState(fruits);

  const handleInputValueChange = (value) => {
    // This time, we need to tell the component to compare the property "name" of an item to the inputValue
    const newFilteredItems = fruits.filter((item) =>
      item.name.toLowerCase().includes(value.toLowerCase()),
    );
    setFilteredItems(newFilteredItems);
  };

  const handleSelectItem = (item) => {
    setSelectedFruit(item);
  };

  return (
    <Stack flexDirection="column" alignItems="start">
      <Autocomplete
        items={filteredItems}
        onInputValueChange={handleInputValueChange}
        onSelectItem={handleSelectItem}
        // This prop is the function that will tell the component how to extract a string that will be used as inputValue
        itemToString={(item) => item.name}
        // This prop is the function that will tell the component how to render each item in the options list
        // In this example the first item will render "Apple ðŸŽ"
        renderItem={(item) => `${item.name} ${item.emoji}`}
      />

      <Paragraph>Selected fruit: {selectedFruit}</Paragraph>
    </Stack>
  );
}
```

Both `itemToString` and `renderItem` are necessary when passing objects as items and they both will receive an "item" as an argument.

If you are using Typescript, you can tell the Autocomplete what is the type of your items to make these functions strongly typed.
You can do that by writing the component like this `<Autocomplete<ItemType> {...props}/>`

### Filling in a list of items

```jsx
function AutocompleteExample() {
  const fruits = [
    { id: 1, name: 'Apple' },
    { id: 2, name: 'Ananas' },
    { id: 3, name: 'Avocado' },
    { id: 4, name: 'Banana' },
    { id: 5, name: 'Coconut' },
  ];

  // The state now stores an array of selected fruits, not just a string
  const [selectedFruits, setSelectedFruits] = React.useState([]);
  const [filteredItems, setFilteredItems] = React.useState(fruits);

  const handleInputValueChange = (value) => {
    const newFilteredItems = fruits.filter((item) =>
      item.name.toLowerCase().includes(value.toLowerCase()),
    );
    setFilteredItems(newFilteredItems);
  };

  const handleSelectItem = (item) => {
    // Every time an item is selected, the component will add the name of the fruit to the selectedFruits array
    setSelectedFruits((prevState) => [...prevState, item.name]);
  };

  return (
    <Stack flexDirection="column" alignItems="start">
      <Autocomplete
        items={filteredItems}
        onInputValueChange={handleInputValueChange}
        onSelectItem={handleSelectItem}
        itemToString={(item) => item.name}
        renderItem={(item) => item.name}
        // When this prop is `true`, it will clean the TextInput after an option is selected
        clearAfterSelect
      />

      <span>
        <Paragraph>Selected fruits:</Paragraph>
        <ul>
          {selectedFruits.map((fruit, index) => (
            <li key={index}>{fruit}</li>
          ))}
        </ul>
      </span>
    </Stack>
  );
}
```

### Error validation with FormControl

```jsx
function AutocompleteExample() {
  const fruits = [
    'Apple ðŸŽ',
    'Ananas ðŸ',
    'Avocado ðŸ¥‘',
    'Banana ðŸŒ',
    'Coconut ðŸ¥¥',
  ];

  const [selectedFruit, setSelectedFruit] = React.useState();
  const [filteredItems, setFilteredItems] = React.useState(fruits);
  const [isInvalid, setIsInvalid] = React.useState(false);

  const handleInputValueChange = (value) => {
    const newFilteredItems = fruits.filter((item) =>
      item.toLowerCase().includes(value.toLowerCase()),
    );
    setFilteredItems(newFilteredItems);
  };

  const handleSelectItem = (item) => {
    setSelectedFruit(item);
  };

  return (
    <Stack flexDirection="column" alignItems="start">
      <FormControl isInvalid={isInvalid}>
        <FormControl.Label>Favorite fruit:</FormControl.Label>

        <Autocomplete
          items={filteredItems}
          onInputValueChange={handleInputValueChange}
          onSelectItem={handleSelectItem}
        />

        {isInvalid && (
          <FormControl.ValidationMessage>Error</FormControl.ValidationMessage>
        )}
      </FormControl>

      <Button onClick={() => setIsInvalid((prevState) => !prevState)}>
        Toggle error message
      </Button>

      <Paragraph>Selected fruit: {selectedFruit}</Paragraph>
    </Stack>
  );
}
```

### Fetching async data

```jsx
function AutocompleteExample() {
  const fruits = [
    'Apple ðŸŽ',
    'Ananas ðŸ',
    'Avocado ðŸ¥‘',
    'Banana ðŸŒ',
    'Coconut ðŸ¥¥',
  ];

  const fetchFruits = (filterBy) =>
    new Promise((resolve) => {
      let result = fruits;
      if (filterBy) {
        result = fruits.filter((item) =>
          item.toLowerCase().includes(filterBy.toLowerCase()),
        );
      }

      setTimeout(() => {
        resolve(result);
      }, 800);
    });

  const [isLoading, setIsLoading] = React.useState(false);
  const [selectedFruit, setSelectedFruit] = React.useState();
  const [items, setItems] = React.useState([]);

  // fetching data when component mounted
  React.useEffect(() => {
    setIsLoading(true);
    fetchFruits().then((result) => {
      setItems(result);
      setIsLoading(false);
    });
  }, []);

  // fetching data on each input value change
  // NOTE: Consider using throttle/debounce here for better performance
  const handleInputValueChange = (value) => {
    setIsLoading(true);
    fetchFruits(value).then((result) => {
      setItems(result);
      setIsLoading(false);
    });
  };

  const handleSelectItem = (item) => {
    setSelectedFruit(item);
  };

  return (
    <Stack flexDirection="column" alignItems="start">
      <Autocomplete
        items={items}
        onInputValueChange={handleInputValueChange}
        onSelectItem={handleSelectItem}
        isLoading={isLoading}
      />

      <Paragraph>Selected fruit: {selectedFruit}</Paragraph>
    </Stack>
  );
}
```

## Content recommendations

- Autocomplete label should be short, contain 1 to 3 words
- Label should be written in a sentence case (the first word capitalized, the rest lowercase)

## Accessibility

- dismisses the dropdown when selecting with the enter key

## Props

<Props of="Autocomplete" />
