---
title: 'Radio'
type: 'component'
status: 'stable'
section: 'formComponents'
slug: /components/radio/
github: 'https://github.com/contentful/forma-36/tree/v5/packages/components/forms/src/Radio'
typescript: ./Radio.tsx,./RadioGroup.tsx
storybook: 'https://f36-storybook.contentful.com/?path=/story/form-elements-radio--basic'
---

`Radio` is a form component, that shows a radio input with its label. It is used to allow users to choose single option from the list.

If you want to let a user select multiple options, use the [Checkbox](/components/checkbox) component.

`Radio.Group` is a component that makes it easier to handle group of radios.

## Import

```js static=true
import { Radio } from '@contentful/f36-components';
// or
import { Radio } from '@contentful/f36-forms';
```

## Examples

### Using as a controlled input

Controlled components in React are those in which form data is handled by the component’s state.

For using the `Radio` as a controlled input, you need to:

- Pass the `isChecked` property, with this property it will already be a controlled component;
- Pass a `onChange` handler, so you can use it to update the value of `isChecked`;

Setting the `isChecked` will already define it as a controlled input.

```jsx file=../../examples/RadioControlledExample.tsx

```

### Using as an uncontrolled input

Uncontrolled components are those for which the form data is handled by the DOM itself. “Uncontrolled” refers to the fact that these components are not controlled by React state.

You can use the `Radio` as an uncontrolled input, for that you can:

- Set the `defaultChecked` property, it will ensure that the checked state can be altered normally.
- Don't set the `isChecked` as it will make the input controlled.

```jsx file=../../examples/RadioUncontrolledExample.tsx

```

### Using with Radio.Group

We also provide the `Radio.Group` component that helps when using multiple radios. You can pass some common properties on the `Radio.Group` level and they will be passed to the radios inside the group.

- `spacing`: This will set how much space should be between the inputs;
- `name`: By setting this property on the `Radio.Group` level, you will set it automatically for all the radios in the group;
- `defaultValue`: This accepts a value that set the `defaultChecked` property for the radio that have the same value **(uncontrolled)**;
- `value`: Same as `defaultValue` but this one sets the `isChecked` property, making the radio group controlled **(controlled)**;
- `onChange`: Handler that will be executed when any radio inside the group receives the event of change.

`Radio.Group` is a **recommended** way of using `Radio` when using it within forms.

```jsx file=../../examples/RadioGroupExample.tsx

```

## Content guidelines

- Use direct, succinct copy that helps a user to successfully complete a form, for example, “Dinner menu (select 1 of 3 options)“
- Do not use punctuation for labels, for example, “Vegetarian“ instead of “Vegetarian.“
- Use sentence style caps in which only the first word of a sentence or term is capitalized, for example, “Dairy free“ instead of “Dairy Free“

## Accessibility

- To ensure `Radio` meets accessibility keyboard standards, set the `name` and `id` properties.

### Radio Group

- Set the `name` prop to give each indivual value the same name
- The Radio.Group should be wrapped in a `<FormControl as="fieldset">`
- In order to easier identify the indivual Radio options as a group and set a label via `<FormControl.Label as="legend">`. For example, “Dinner menu (select 1 of 3 options): (x) Menu 1, () Menu 2, () Menu 3.”
- For more information about validation and controlling form fields, please refer to [FormControl](./form-control).

### Keyboard Usage

- To switch between options with the keyboard, use the “tab + space” and the arrow keys (“←”, ”↑”, “→”, and “↓”).

## Props (API reference)

### Radio

<PropsTable of="Radio" />

### Radio.Group

<PropsTable of="RadioGroup" />

## Density support

This component supports multiple densities thanks to the [useDensity](/hooks/use-density) hook and automatically adjusts its styling for each density (when wrapped with the `DensityProvider`).
